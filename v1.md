# Tree Traversal Algorithms

Tree traversal algorithms are used to visit all nodes of a tree. There are three types of tree traversal algorithms:
1. Pre-order Traversal: Process the current node first, then recursively traverse the left subtree and right subtree.
2. In-order Traversal: Recursively traverse the left subtree first, then process the current node, and finally traverse the right subtree.
3. Post-order Traversal: Recursively traverse the left subtree first, then the right subtree, and finally process the current node.

 ```java
 public class Main {
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();

        // Construct the binary tree manually
        //        1
        //       / \
        //      2   3
        //     / \
        //    4   5
        tree.root = new Node(1);             // Root node
        tree.root.left = new Node(2);        // Left child of root
        tree.root.right = new Node(3);       // Right child of root
        tree.root.left.left = new Node(4);   // Left child of node 2
        tree.root.left.right = new Node(5);  // Right child of node 2

        // Perform pre-order traversal (Root -> Left -> Right)
        // Expected output: 1 2 4 5 3
        System.out.println("Pre-order Traversal:");
        tree.preOrderTraversal(tree.root); // Starts from the root node

        // Perform in-order traversal  (Left -> Root -> Right) 
        // Expected output: 4 2 5 1 3
        System.out.println("\nIn-order Traversal:");
        tree.inOrderTraversal(tree.root);

        // Perform post-order traversal (Left -> Right -> Root)
        // Expected output: 4 5 2 3 1
        System.out.println("\nPost-order Traversal:");
        tree.postOrderTraversal(tree.root);
    }
}
```
## Pre-order Traversal
In pre-order traversal, the current node is processed first, then the left subtree, and finally the right subtree. The general algorithm for pre-order traversal is:

1. Process the current node.
2. Recursively traverse the left subtree.
3. Recursively traverse the right subtree.

1. Pre-order Traversal:
```java
public void preOrderTraversal(Node node) {
    if (node == null) return;
    System.out.print(node.data + " "); // Process current node first
    preOrderTraversal(node.left);      // Then traverse left subtree 
    preOrderTraversal(node.right);     // Finally traverse right subtree
}
```
# Pre-order Traversal Example Stack Frame Diagram

![alt text](mermaid/preOrderStackFrame.png)


### Example
Given the following binary tree:
```
//        1
//       / \
//      2   3
//     / \
//    4   5
tree.root = new Node(1);             // Root node
tree.root.left = new Node(2);        // Left child of root
tree.root.right = new Node(3);       // Right child of root
tree.root.left.left = new Node(4);   // Left child of node 2
tree.root.left.right = new Node(5);  // Right child of node 2
```
# Pre Order Traversal Example Method Call Control Flow Diagram
![alt text](mermaid/preorder.png)

The pre-order traversal algorithm visits each node in the following order: 1 -> 2 -> 4 -> 5 -> 3. The output of the pre-order traversal algorithm is:
```
Pre-order Traversal:
1 2 4 5 3
```

### Stack Frame Diagram for Pre-order Traversal
```
|---------------------|
| preOrderTraversal(1)|
|---------------------|
| preOrderTraversal(2)|
|---------------------|
| preOrderTraversal(4)|
|---------------------|
| preOrderTraversal(null)|
|---------------------|
| preOrderTraversal(null)|
|---------------------|
| preOrderTraversal(5)|
|---------------------|
| preOrderTraversal(null)|
|---------------------|
| preOrderTraversal(null)|
|---------------------|
| preOrderTraversal(3)|
|---------------------|
| preOrderTraversal(null)|
|---------------------|
| preOrderTraversal(null)|
|---------------------|
```
# Pre Order Traversal Stack Frame Diagram
![alt text](mermaid/preOrderStackFrame.png)



## In-order Traversal
In in-order traversal, the left subtree is recursively traversed first, then the current node is processed, and finally, the right subtree is traversed. The general algorithm for in-order traversal is:

1. Recursively traverse the left subtree.
2. Process the current node.
3. Recursively traverse the right subtree.
2. In-order Traversal:
```java
public void inOrderTraversal(Node node) {
    if (node == null) return;
    inOrderTraversal(node.left);       // Traverse left subtree first
    System.out.print(node.data + " "); // Then process current node
    inOrderTraversal(node.right);      // Finally traverse right subtree
}
```

# In order Traversal Example Method Call Control Flow Diagram
![alt text](mermaid/inorder.png) 

# Stack Frame Diagram 

```java
|---------------------|
| inOrderTraversal(1) |
|---------------------|
| inOrderTraversal(2) |
|---------------------|
| inOrderTraversal(4) |
|---------------------|
| inOrderTraversal(null)|
|---------------------|
| inOrderTraversal(null)|
|---------------------|
| inOrderTraversal(5) |
|---------------------|
| inOrderTraversal(null)|
|---------------------|
| inOrderTraversal(null)|
|---------------------|
| inOrderTraversal(3) |
|---------------------|
| inOrderTraversal(null)|
|---------------------|
| inOrderTraversal(null)|
|----------------
```

<!-- TODO: Stack Frame Chart for In-order Traversal method and stack frame
 -->
 # In Order Traversal Sequence Diagram

## Details : Each method call is represented by a solid arrow (->)
Each return is represented by a dashed arrow (-->)
The printing operations are shown as notes above the respective method calls
The activation bars (vertical rectangles) show when each method is active on the stack
The activation bars are colored to differentiate between different methods

The complete execution flow results in printing: 4, 2, 5, 1, 3, which is the correct in-order traversal sequence
```mermaid
sequenceDiagram
    participant M as Main
    participant T1 as inOrderTraversal(1)
    participant T2 as inOrderTraversal(2)
    participant T4 as inOrderTraversal(4)
    participant T5 as inOrderTraversal(5)
    participant T3 as inOrderTraversal(3)

    M->>+T1: call(1)
    T1->>+T2: visit left(2)
    T2->>+T4: visit left(4)
    Note over T4: Print: 4
    T4-->>-T2: return (left: null)
    T2-->>T2: return (right: null)
    Note over T2: Print: 2
    T2->>+T5: visit right(5)
    Note over T5: Print: 5
    T5-->>-T2: return (left: null)
    T2-->>T2: return (right: null)
    T2-->>-T1: return
    Note over T1: Print: 1
    T1->>+T3: visit right(3)
    Note over T3: Print: 3
    T3-->>-T1: return (left: null)
    T1-->>T1: return (right: null)
    T1-->>-M: return
```
# Color Coded Stack Frame Diagram

The sequence diagram uses different colors to represent method execution levels:

- **Gray**: Main method execution
- **Light Red**: Root level - inOrderTraversal(1) and its scope
- **Light Green**: Left subtree - inOrderTraversal(2) and children (4,5)
- **Light Blue**: Right subtree - inOrderTraversal(3) execution

This color scheme helps visualize:
- Nested call hierarchy
- Stack frame lifetime
- Subtree traversal boundaries

The diagram clearly shows how recursion:
1. Processes the left subtree (green)
2. Returns to complete the root (red)
3. Finishes with the right subtree (blue)

```mermaid
sequenceDiagram
    participant M as Main
    participant T1 as inOrderTraversal(1)
    participant T2 as inOrderTraversal(2)
    participant T4 as inOrderTraversal(4)
    participant T5 as inOrderTraversal(5)
    participant T3 as inOrderTraversal(3)

    rect rgb(200, 200, 200)
        M->>+T1: call(1)
    end
    rect rgb(255, 200, 200)
        T1->>+T2: visit left(2)
        rect rgb(200, 255, 200)
            T2->>+T4: visit left(4)
            Note over T4: Print: 4
            T4-->>-T2: return (left: null)
            T2-->>T2: return (right: null)
            Note over T2: Print: 2
            T2->>+T5: visit right(5)
            Note over T5: Print: 5
            T5-->>-T2: return (left: null)
            T2-->>T2: return (right: null)
        end
        T2-->>-T1: return
        Note over T1: Print: 1
        rect rgb(200, 200, 255)
            T1->>+T3: visit right(3)
            Note over T3: Print: 3
            T3-->>-T1: return (left: null)
            T1-->>T1: return (right: null)
        end
    end
    T1-->>-M: return
```

<!-- TODO: Stack Frame Chart for Post-order Traversal method and stack frame
 -->

## Post-order Traversal
In post-order traversal, the left subtree is recursively traversed first, then the right subtree, and finally, the current node is processed. The general algorithm for post-order traversal is:

1. Recursively traverse the left subtree.
2. Recursively traverse the right subtree.
3. Process the current node.
3. Post-order Traversal:
```java
public void postOrderTraversal(Node node) {
    if (node == null) return;
    postOrderTraversal(node.left);      // Traverse left subtree first
    postOrderTraversal(node.right);     // Then traverse right subtree
    System.out.print(node.data + " ");  // Finally process current node
}
```


# Stack Frame Diagram

```java
|---------------------|
| postOrderTraversal(1)|
|---------------------|
| postOrderTraversal(2)|
|---------------------|
| postOrderTraversal(4)|
|---------------------|
| postOrderTraversal(null)|
|---------------------|
| postOrderTraversal(null)|
|---------------------|
| postOrderTraversal(5)|
|---------------------|
| postOrderTraversal(null)|
|---------------------|
| postOrderTraversal(null)|
|---------------------|
| postOrderTraversal(3)|
|---------------------|
| postOrderTraversal(null)|
|---------------------|
| postOrderTraversal(null)|
|---------------------|
```

## Complexity Analysis
The time complexity of tree traversal algorithms is O(n), where n is the number of nodes in the tree. The space complexity of tree traversal algorithms is O(h), where h is the height of the tree. The space complexity is O(h) because the recursive calls are stored on the stack, and the maximum depth of the stack is equal to the height of the tree. In the worst-case scenario, the height of the tree can be equal to the number of nodes in the tree, resulting in O(n) space complexity.

## Summary
Tree traversal algorithms are used to visit all nodes of a tree. There are three types of tree traversal algorithms: pre-order traversal, in-order traversal, and post-order traversal. Pre-order traversal processes the current node first, then recursively traverses the left subtree and right subtree. In-order traversal recursively traverses the left subtree first, then processes the current node, and finally traverses the right subtree. Post-order traversal recursively traverses the left subtree first, then the right subtree, and finally processes the current node. The time complexity of tree traversal algorithms is O(n), and the space complexity is O(h), where n is the number of nodes in the tree and h is the height of the tree.

```mermaid
graph TD
    1[1] --> 2[2]
    1 --> 3[3]
    2 --> 4[4]
    2 --> 5[5]

   subgraph Tree
        1[1]:::root --> 2[2]:::internal
        1 --> 3[3]:::internal
        2 --> 4[4]:::leaf
        2 --> 5[5]:::leaf
        3 --> null1[null]:::nullNode
        3 --> null2[null]:::nullNode
        4 --> null3[null]:::nullNode
        4 --> null4[null]:::nullNode
        5 --> null5[null]:::nullNode
        5 --> null6[null]:::nullNode
    end

    subgraph "Frame Execution"
        direction TB
        SF1["Frame 1: post(1)"] --> SF2["Frame 2: post(2)"]
        SF2 --> SF3["Frame 3: post(4)"]
        SF3 --> SF4["Frame 4: post(null)"]
        SF4 --> |return| SF3
        SF3 --> SF5["Frame 5: post(null)"]
        SF5 --> |"visit(4)"| SF3p["Frame 3: complete"]
        SF3p --> |return| SF2
        SF2 --> SF6["Frame 6: post(5)"]
        SF6 --> SF7["Frame 7: post(null)"]
        SF7 --> |return| SF6
        SF6 --> SF8["Frame 8: post(null)"]
        SF8 --> |"visit(5)"| SF6p["Frame 6: complete"]
        SF6p --> |"visit(2)"| SF2p["Frame 2: complete"]
        SF2p --> |return| SF1
        SF1 --> SF9["Frame 9: post(3)"]
        SF9 --> SF10["Frame 10: post(null)"]
        SF10 --> |return| SF9
        SF9 --> SF11["Frame 11: post(null)"]
        SF11 --> |"visit(3)"| SF9p["Frame 9: complete"]
        SF9p --> |"visit(1)"| SF1p["Frame 1: complete"]
    end

    style 1 fill:#f9f,stroke:#333,stroke-width:4px
    style 2 fill:#bbf,stroke:#333,stroke-width:2px
    style 3 fill:#bbf,stroke:#333,stroke-width:2px
    style 4 fill:#ddf,stroke:#333,stroke-width:2px
    style 5 fill:#ddf,stroke:#333,stroke-width:2px
```
 
```mermaid
graph TD
    classDef root fill:#f9f,stroke:#333,stroke-width:4px
    classDef internal fill:#bbf,stroke:#333,stroke-width:2px
    classDef leaf fill:#ddf,stroke:#333,stroke-width:2px
    classDef nullNode fill:#eee,stroke:#999,stroke-width:1px,stroke-dasharray: 5 5
    classDef note fill:#fff,stroke:#333,stroke-width:1px
    
 

    subgraph Legend
        L1[Root Node]:::root
        L2[Internal Node]:::internal
        L3[Leaf Node]:::leaf
        L4[Null Node]:::nullNode
        N1[Execution Order: 4 → 5 → 2 → 3 → 1]:::note
        N2[Post-order: Left → Right → Root]:::note
    end

    style S1 fill:#f9f,stroke:#333
    style S2 fill:#bbf,stroke:#333
    style S3 fill:#ddf,stroke:#333
    style S4 fill:#ddf,stroke:#333
    style S5 fill:#ddf,stroke:#333
    style S6 fill:#ddf,stroke:#333
    style S7 fill:#bbf,stroke:#333
    style S8 fill:#bbf,stroke:#333
    style S9 fill:#bbf,stroke:#333
    style S10 fill:#f9f,stroke:#333
```
# Post-order Traversal Sequence Diagram
```mermaid
sequenceDiagram
    participant M as Main
    participant T1 as postOrder(1)
    participant T2 as postOrder(2)
    participant T4 as postOrder(4)
    participant T5 as postOrder(5)
    participant T3 as postOrder(3)

    rect rgb(240, 240, 240)
        Note over M,T3: Left Subtree Traversal
        M->>+T1: start
        T1->>+T2: traverse left
        T2->>+T4: traverse left
        T4-->>-T2: visit(4)
        T2->>+T5: traverse right
        T5-->>-T2: visit(5)
        T2-->>-T1: visit(2)
    end
    
    rect rgb(230, 240, 230)
        Note over M,T3: Right Subtree Traversal
        T1->>+T3: traverse right
        T3-->>-T1: visit(3)
    end
    
    rect rgb(240, 230, 240)
        Note over M,T3: Root Node Visit
        T1-->>-M: visit(1)
    end
```